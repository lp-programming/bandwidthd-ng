* Live
This is very similar to the Graph code, but instead of loading the data from the database, this captures it in real-time
and genrates live graphs. If you need visualized output on a system without postgres, this is basically the same as the
classic program, just without he database tie-in.

#+begin_src c++ :tangle Live.cpp
import BandwidthD;
import Memory;
import TrafficGraph;
import Syslog;
import format_ip;

import <chrono>;
import <string>;
import <print>;
import <vector>;
import <unordered_map>;
import <array>;

using namespace std::chrono_literals;
using namespace bandwidthd;
using namespace lpprogramming;

using Logger = lpprogramming::Syslog::Logger;

template<typename DB>
class MemorySensor: public Sensor<MemorySensor<DB>, Modes::BothDefault>  {
public:

  DB db;
  MemorySensor& base;
  MemorySensor(Config& config): Sensor<MemorySensor<DB>, Modes::BothDefault>(config), db{config}, base(*this) { }

  int Main() {
    uint32_t count{0};
    for (;;) {
      const auto starttime = std::chrono::system_clock::now();
      while ((std::chrono::system_clock::now() - starttime) < base.config.interval) {
        if (this->Poll()) {
          this->Step();
        }
      }
      count++;
      db.CollateData(base.ips, base.txrx, base.config.interval);
      base.ips.clear();
      base.txrx.clear();
      db.CollateData(base.ips, base.txrx6, base.config.interval);
      base.ips.clear();
      base.txrx6.clear();
      if (! (count++ % (base.config.skip_intervals + 1))) {
        TrafficGraph grapher{{.width=1920, .height=1080, .left_margin=150, .top_margin=100, .bottom_margin=50, .right_margin=50}};
        db.Graph(grapher);
      }
      return 1;
    }
    return 0;
  } 
};

int Main(const size_t argc, const char * const * const argv) {
  Config config{};
  config.graph_intervals = GraphIntervals{GraphInterval::Hour};
  config.htdocs_dir = "/tmp/bdcpp/htdocs";
  config.interval = 200s;
  config.syslog_prefix = "bandwidthd-live";

  const std::vector<std::string> args{argv, argv + argc};
  if (argc < 5 || !(argc % 2)) {
    std::println("Usage: {} --dev DEV [--filter FILTER] [--promiscuous BOOL] --subnet <CIDR> [--subnet <CIDR>...] [--notsubnet <CIDR>...] [--txrxsubnet <CIDR>...]", args.at(0));
    std::println("Wrong number of args");
    return 1;
  }
  
  config.dev = args.at(2);
  config.filter = "tcp";

  for (auto i = 3uz; i < argc; i += 2uz) {
    auto arg = args.at(i);
    if (arg == std::string{"--filter"}) {
      config.filter = args.at(i + 1uz);
    }
    else if (arg == std::string{"--promiscuous"}) {
      config.promisc = args.at(i + 1uz) == "true";
    }
    else if (arg == std::string{"--subnet"}) {
      auto& sn = config.subnets.emplace_back(args.at(i + 1uz));

      Logger::info(std::format("Monitoring subnet {} with netmask {}",
                               util::format_ip(sn.ip, sn.family),
                               util::format_ip(sn.mask, sn.family)));
    }
    else if (arg == std::string{"--notsubnet"}) {
      auto& sn = config.notsubnets.emplace_back(args.at(i + 1uz));
      Logger::info(std::format("Ignoring subnet {} with netmask {}",
                               util::format_ip(sn.ip, sn.family),
                               util::format_ip(sn.mask, sn.family)));
    }
    else if (arg == std::string{"--txrxsubnet"}) {
      auto& sn = config.txrxsubnets.emplace_back(args.at(i + 1uz));
      Logger::info(std::format("Tracking subnet {} with netmask {}",
                               util::format_ip(sn.ip, sn.family),
                               util::format_ip(sn.mask, sn.family)));
    }
  }

  MemorySensor<Memory> sensor{config};
  
  
  return sensor.Main();
}

int main(const int argc, const char * const * const argv) {
  return Main(static_cast<const size_t>(argc), argv);
}

#+end_src
