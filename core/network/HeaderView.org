* HeaderView
This is by far the ugliest and worst code in this project. Strictly, it was legal ISO C++ prior to C++20, since the
underlying objects were properly allocated by the kernel via kmalloc or similar, and have had their initialization done
by the kernel. Starting with C++20, only ~calloc~ and ~malloc~ portably start object lifetimes. I see that as a
significant defect in the ISO C++ spec, since the underlying behavior of ~kmalloc~ doesn't magically change when you
write your userspace code in C++26. So this module assumes, but cannot prove, the buffer contains a properly initialized
ethernet packet object.

Even then, the standard only guarantees correct behavior if you treat the objects as their correct type (an ethernet
packet), or as an array of ~std::byte~ (with a C-style char array as an acceptable stand-in for the latter). Using
~std::array<char>~ and ~std::span~ /sucks/ compared to ~std::string_view~, especially on platforms which require copies
for aligned access. So that makes this module fully non-conforming and non-portable. But it works with clang, and I'd
rather deal with non-portability than spans for this.

For platforms which have 0-cost access to unaligned data, we just cast to the underlying objects in-place. Otherwise, we
make a copy and cast there. We /could/ use interning to detect when we've already created each object, but the memory
cost to duplicate them is generally less than the computation required to reuse them.

Note that on alignment-required platforms, the ~HeaderView~ must outlive the last referenced header.
#+begin_src c++ :tangle HeaderView.cppm
export module HeaderView;

import <string>;
import <string_view>;
import <vector>;

namespace {
  constexpr bool platform_allows_unaligned_access = 
#if defined(__x86_64__) || defined(_M_X64) || defined(__i386) || defined(_M_IX86) || defined(__amd64__) || defined(__aarch64__) || defined(__arm64__)
    true;
#else
    false;  // Unknown platform, assume strict alignment
#endif
  
}

namespace bandwidthd {
  export
  class HeaderView {
    const std::string_view buffer;
    size_t offset{0};
  
    std::vector<std::string> subheaders{};
  

  public:
    constexpr explicit HeaderView(std::string_view buffer) noexcept: buffer(buffer) {}

    constexpr void reset() noexcept {
      offset = 0;
    }
    constexpr size_t tell() const noexcept {
      return offset;
    }

    constexpr size_t remaining() const noexcept {
      return buffer.size() - offset;
    }

    template <typename T>
    constexpr bool can_read() const noexcept {
      return remaining() >= sizeof(T);
    }

    template <typename T>
    constexpr const T& next_header() {
      if (!can_read<T>()) {
        throw std::out_of_range("HeaderView: insufficient buffer for header");
      }

      const char* ptr = buffer.data() + offset;
      offset += sizeof(T);

      if constexpr (platform_allows_unaligned_access) {
        return *reinterpret_cast<const T*>(ptr);
      }
      else {
        return reinterpret_cast<T&>(subheaders.emplace_back(ptr, ptr + sizeof(T)));
      }
    }

    // Peek at next header without advancing offset
    template <typename T>
    constexpr const T& peek_header() {
      if (!can_read<T>()) {
        throw std::out_of_range("HeaderView: insufficient buffer to peek header");
      }

      const char* ptr = buffer.data() + offset;

      if constexpr (platform_allows_unaligned_access) {
        return *reinterpret_cast<const T*>(ptr);
      }
      else {
        return reinterpret_cast<T&>(subheaders.emplace_back(ptr, ptr + sizeof(T)));
      }
    }

    constexpr void skip_forward(size_t b) {
      offset += b;
    }

    // Skip next header of size T
    template <typename T>
    constexpr void skip_header() {
      if (!can_read<T>()) {
        throw std::out_of_range("HeaderView: cannot skip, insufficient buffer");
      }
      offset += sizeof(T);
    }
  };
}
#+end_src
