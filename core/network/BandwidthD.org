* BandwidthD
This is the core of bandwidthd-ng. It handles talking to libpcap, and presents a pollable interface to downstream code.
For most applications, the default IPv4 and IPv6 processors are sufficient (see the demo project for an example of /not/
using the default). 

#+begin_src c++ :tangle BandwidthD.cppm
export module BandwidthD;
export import Config;
export import Statistics;
export import IPData;

import <source_location>;
import <chrono>;
import <format>;
import <iostream>;
import <pcap/pcap.h>;
import <poll.h>;
import <netinet/ip.h>;
import <netinet/ip6.h>;
import <net/ethernet.h>;
import <string>;
import <vector>;

import SyscallHelper;
import HeaderView;
import Syslog;
import net_integer;
import Parser;
import EnumFlags;
import Constants;
import VlanHeader;
import IPv4DefaultMixin;
import IPv6DefaultMixin;
import PCap;

export using namespace ::lpprogramming;
export using namespace ::lpprogramming::types::net_integer;

using namespace std::chrono_literals;
using Logger = lpprogramming::Syslog::Logger;

using lpprogramming::SyscallHelper::Syscall;
using lpprogramming::SyscallHelper::failure_message;
#+end_src
** ModeFlags
This controls if libpcap reports events for IPv4 or IPv6. At least one processing mode must be specified, which is
compile-time enforced by a constraint.

#+begin_src c++ :tangle BandwidthD.cppm

namespace bandwidthd {
  using EnumFlags::FlagSet;
  export enum class ModeFlag {
    IPv4Default = 1,
    IPv6Default = 2,
    IPv4 = 4,
    IPv6 = 8
  };

  export struct Modes : FlagSet<ModeFlag> {
    using ModeFlags = FlagSet<ModeFlag>;
    constexpr Modes(ModeFlags F): ModeFlags(F) {}
    static constexpr ModeFlags IPv4 = ModeFlags{ModeFlag::IPv4};
    static constexpr ModeFlags IPv6        = ModeFlags{ModeFlag::IPv6};
    static constexpr ModeFlags IPv4Default = ModeFlags{ModeFlag::IPv4Default};
    static constexpr ModeFlags IPv6Default = ModeFlags{ModeFlag::IPv6Default};
    static constexpr ModeFlags Both        = IPv4 | IPv6;
    static constexpr ModeFlags BothDefault = IPv4Default | IPv6Default;
    static constexpr ModeFlags Any = Both | BothDefault;
    static constexpr ModeFlags NeedsIPv4 = IPv4 | IPv4Default;
    static constexpr ModeFlags NeedsIPv6 = IPv6 | IPv6Default;
  };

  template<Modes m>
  struct EmptyMixin {};

  template <typename BD, Modes M>
  using IPv4Mixin = std::conditional_t<
    M & Modes::IPv4Default,
    IPv4DefaultMixin<BD>,
    EmptyMixin<Modes::IPv4>
    >;

  template <typename BD, Modes M>
  using IPv6Mixin = std::conditional_t<
    M & Modes::IPv6Default,
    IPv6DefaultMixin<BD>,
    EmptyMixin<Modes::IPv6>
    >;

  template <typename T>
  concept HasIPv4Processor = requires {
    { &T::ProcessIPv4 } -> std::same_as<
      void (T::*)(const uint16_t, const ip&, HeaderView&)
      >;
  };

  template <typename T>
  concept HasIPv6Processor = requires {
    { &T::ProcessIPv6 } -> std::same_as<
      void (T::*)(const uint16_t, const ip6_hdr&, HeaderView&)
      >;
  };

  template <typename Derived>
  concept HasOwnIPv4Processor =
  requires {
    requires &Derived::ProcessIPv4 != &IPv4DefaultMixin<Derived>::ProcessIPv4;
  };

  template <typename Derived>
  concept HasOwnIPv6Processor =
  requires {
    requires &Derived::ProcessIPv6 != &IPv6DefaultMixin<Derived>::ProcessIPv6;
  };

  template <typename BD, Modes M>
  concept SaneMode = (M & Modes::Any)
    && (!(M & Modes::IPv4) || HasIPv4Processor<BD>)
    && (!(M & Modes::IPv6) || HasIPv6Processor<BD>)
    && (!(M & Modes::IPv4 && M & Modes::IPv4Default))
    && (!(M & Modes::IPv6 && M & Modes::IPv6Default))
    ;
  template <typename T, Modes M>
  requires SaneMode<T, M>
  struct SanityChecker {
    constexpr static bool Valid() {
      if constexpr (M & Modes::IPv4Default) {
        static_assert(!HasOwnIPv4Processor<T>, "Cannot supply ProcessIPv4 in derived class when selecting IPv4Default");
      }
      if constexpr (M & Modes::IPv6Default) {
        static_assert(!HasOwnIPv6Processor<T>, "Cannot supply ProcessIPv6 in derived class when selecting IPv6Default");
      }
      return true;
    }
  };

#+end_src
** Sensor
This uses CRTP from the chosen mixins to enable default handling. It also is /itself/ a CRTP template for applications
to use. Unfortunately, CRTP relies on /Duck Typing/, and gives you a fairly opaque error message when the derived type
doesn't supply a required member of the implicit interface.  Historically, you could make that interface explicit by
having the derived type inherit from a pure abstract base class, and count on the compiler de-virtualizing it (with
mixed success). However C++23 concepts let us specify the requirements of the interface explicitly, generting nice error
messages immediately.

Writing the constraint itself is messy, at least without C++26 reflection, but using it is easy. In this case, we
enforce the CRTP derived type has a ~ProcessIPvX~ method for each IP type it wants to see. This ensures you have a
complete and working type, even if the compiler never generates the code that /requires/ the interface elements. In this
way, we avoid the case where adding a function call to ~Step()~ breaks things that aren't obviously related to it.

#+begin_src c++ :tangle BandwidthD.cppm
  export
  template <typename BD, Modes M = {Modes::IPv4Default}>
  class Sensor : public IPv4Mixin<BD,M>, public IPv6Mixin<BD,M> {
    friend IPv4Mixin<BD,M>;
    friend IPv6Mixin<BD,M>;
    PCap pc;
    int selectable_fd{-1};
    int DataLink{};
    bpf_program fcode;
  public:
    Config config;
    Sensor(Config& config): IPv4Mixin<BD,M>(), IPv6Mixin<BD,M>(), pc{config.dev}, config(config) {
      static_assert(SanityChecker<BD,M>::Valid(), "Missing method or inconsistent mode selection");
      Logger::init(config.syslog_prefix, Syslog::Option::PID, Syslog::Facility::DAEMON);
      Logger::info(std::format("Opening {}", config.dev));
      pc.PCapCall(pcap_set_promisc, {"pcap_set_promisc failed"}, static_cast<int>(config.promisc));
      pc.PCapCall(pcap_set_snaplen, {"pcap_set_snaplen failed"}, config.snaplen);
      pc.PCapCall(pcap_activate, {"pcap_activate failed"});
      pc.PCapCall(pcap_setnonblock, {"pcap_setnonblock failed"}, true);
      pc.PCapCall(pcap_compile, {"pcap_compile failed"}, &fcode, config.filter.c_str(), 1, 0u);
      pc.PCapCall(pcap_setfilter, {"Malformed libpcap filter string"}, &fcode);
      DataLink = pc.PCapCall<PCap::NEGATIVE>(pcap_datalink, {"Malformed libpcap filter string"});
      switch (DataLink) {
      default:
        Logger::info("Unkown datalink type, defaulting to ethernet");
      case DLT_EN10MB:
        Logger::info("Packet Encoding: Ethernet");
        break;
      case DLT_LINUX_SLL:
      case DLT_RAW:
      case DLT_IEEE802:
        Logger::info("Untested packet encoding: Token Ring");
        break;
      }
      selectable_fd = pc.PCapCall<PCap::NEGATIVE>(pcap_get_selectable_fd, {"failed to get libpcap selectable fd"});
    }

    int Poll(const std::chrono::seconds timeout = 1s) const {
      pollfd pfd {
        selectable_fd,
        POLLIN,
        0x00
      };

      std::chrono::milliseconds milis{timeout};
      
      int r = Syscall(poll, {"polling libpcap fd failed"}, &pfd, 1ul, milis.count());
      return r;
    }

    auto IPV4Received(this auto& self, const pcap_pkthdr &, const ip& iheader, HeaderView& view ) {
      static_cast<BD&>(self).ProcessIPv4(static_cast<net_u16>(iheader.ip_len).host(), iheader, view);
    }

    auto IPV6Received(this auto& self, const pcap_pkthdr &, const ip6_hdr& iheader, HeaderView& view ) {
      static_cast<BD&>(self).ProcessIPv6(static_cast<net_u16>(iheader.ip6_ctlun.ip6_un1.ip6_un1_plen).host(), iheader, view);
    }

    auto PacketCallback(const pcap_pkthdr &header, const std::string_view packet) {
      HeaderView view{packet};
      const auto& ethhdr = view.next_header<ether_header>();
      net_u16 ether_type{ethhdr.ether_type};
      while (ether_type == ETHER_VLAN) {
        const auto& vlanhdr = view.next_header<VlanHeader>();
        ether_type = net_u16{vlanhdr.encapsulated_proto};
      }

      if (ether_type == ETHER_IPV4) {
        if constexpr (M & Modes::NeedsIPv4) {
          const auto& iheader = view.next_header<ip>();
          IPV4Received(header, iheader, view);
          return;
        }
      }
      else if (ether_type == ETHER_IPV6) {
        if constexpr (M & Modes::NeedsIPv6) {
          const auto& i6header = view.peek_header<ip6_hdr>();
          if (i6header.ip6_ctlun.ip6_un2_vfc>>4 == 6) {
            IPV6Received(header, i6header, view);
            return;
          }
        }
      }
    }

    int Step() {
      int r = pc.PCapCall<PCap::NEGATIVE>
        (pcap_dispatch,
         {"pcap_dispatch failed"},
         -1,
         [](u_char *user, const pcap_pkthdr *header, const u_char *bytes)
         {
           const std::string_view packet{reinterpret_cast<const char*>(bytes), header->caplen};
           if (header->caplen < 28) {
             return;
           }
           BD& self = *reinterpret_cast<BD*>(user);
           try {
             return self.PacketCallback(*header, packet);
           }
           catch(std::out_of_range& e) {
             std::println("got packet of {} bytes, which contained malformed headers", header->caplen);
             std::println("hex: {}", hex_encode(header->caplen, bytes));         
           }
         }, reinterpret_cast<u_char*>(this)
         );
      return r;
    }
    private:
    template<NetIntegerIP N>
    [[nodiscard]]
    inline std::pair<bool, bool> is_allowed(this const auto& self, const N srcip, const N dstip) noexcept{
      bool src_ok{false};
      bool dst_ok{false};
    
      for (const auto& s : self.config.subnets) {
        src_ok |= s.contains(srcip);
        dst_ok |= s.contains(dstip);
        if (src_ok && dst_ok) {
          break;
        }
      }

      if (src_ok || dst_ok) {
        for (const auto& s : self.config.notsubnets) {
          src_ok &= !(s.contains(srcip));
          dst_ok &= !(s.contains(dstip));
          if (!(src_ok || dst_ok)) {
            break;
          }
        }
      }
      return {src_ok, dst_ok};
    }
    static std::string hex_encode(const auto m, const auto bytes) {
      std::string r{};
      for (size_t i = 0; i < m; ++i) {
        r += std::format("{:02x}", bytes[i]);
      }
      return r;
    }

  };
}
#+end_src
