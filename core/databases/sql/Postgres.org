* Postgres
This is the postgres driver. pqxx is already well adapted to this execution model, so the only real work is formatting
the query arguments.
#+begin_src c++ :tangle Postgres.cppm
export module Postgres;
import <format>;
export import <pqxx/pqxx>;

import string_util;
import Config;


using namespace lpprogramming;

export
class PostgresDB  {
public:
  using params = pqxx::params;
  using prepared_t = std::string;
  
  pqxx::connection connection;

  PostgresDB(const Config& config) : connection(config.psql_connect_string.c_str()) {
  }

  pqxx::work begin() {
    return pqxx::work{connection};
  };

  inline auto query(auto& txn, const auto& stmt, const auto& args) {
    return txn.exec(stmt, args);
  }
  
  constexpr auto prepare(const std::string_view query) {
    int ctr = 1;
    auto res = util::iter_replace
      (query, "$$",
       [&](std::string acc, auto&& subrange) {
         acc += std::format("${}", ctr++);
         acc += util::iter_replace
           (std::string{subrange.begin(), subrange.end()},
            "$now",
            [&](std::string acc2, auto&& subrange2) {
              acc2 += std::format("${}::timestamp", ctr++);
              acc2.append(subrange2.begin(), subrange2.end());
              return acc2;
            });
         
         return acc;
       });
    return res;
  }
  
};

#+end_src

** Stub
If we are building without sqlite support, then we just need an empty module stub to include elsewhere.

#+begin_src c++ :tangle PostgresStub.cppm
export module Postgres;

export
class PostgresDB  {
public:
  PostgresDB(auto&) {}

};

#+end_src
