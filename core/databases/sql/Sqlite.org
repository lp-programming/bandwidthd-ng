* Sqlite
Unlike the psql version, the C++ Sqlite wrapper doesn't naturally support the connection->cursor->transaction->exec
model. So we provide that via a shim. It /mostly/ works, but the exec method is defined on statements rather than on
transactions. Also arguments have to be explicitly bound in advance, and cleared after.

#+begin_src c++ :tangle Sqlite.cppm
export module Sqlite;
import <limits>;
import <ranges>;
export import <SQLiteCpp/SQLiteCpp.h>;

import static_for;
import Config;
import string_util;


using namespace lpprogramming;
using util::static_for;

template<typename DB>
struct Transaction {
  DB& db;
  SQLite::Transaction txn;
  Transaction(auto& db): db(db), txn(SQLite::Transaction{db.connection}) {}

  auto exec(const std::string& query) {
    return db.prepare(query).exec();
  }
  template<typename... Ns>
  auto exec(const std::string& query, const std::tuple<Ns...>& args) {
    return exec(db.prepare(query), args);
  }
  template<typename... Ns>
  auto bind(auto& query, const std::tuple<Ns...>& args) {
    query.reset();
    constexpr std::size_t N = std::tuple_size_v<std::tuple<Ns...>>;
    static_assert(N < std::numeric_limits<int>::max(), "Too many args to exec");
    static_for<N>([&]<std::size_t n>(std::integral_constant<std::size_t, n>) {
        const auto& arg = std::get<n>(args);
        using T = std::remove_cvref_t<decltype(arg)>;
        
        if constexpr ((std::is_same_v<T, long long>) || (std::is_unsigned_v<T> && std::is_integral_v<T>)) {
          query.bind(static_cast<int>(n + 1), static_cast<int64_t>(arg));
        }
        else {
          query.bind(static_cast<int>(n + 1), arg);
        }
      });
    
  }
  template<typename... Ns>
  auto exec(SQLite::Statement& query, const std::tuple<Ns...>& args) {
    bind(query, args);
    return query.exec();
  }
  auto commit() {
    return txn.commit();
  }
};

#+end_src
** Cursor
With the transaction shim already made, the cursor is pretty much the same as psql's version.
#+begin_src c++ :tangle Sqlite.cppm

class Col {
  SQLite::Column col;
  public:
  Col(auto c) : col(c) {}
  template<typename T>
  T as() const {
    return static_cast<T>(col);
  }
};

class Row {
  SQLite::Statement& stmt;
  public:
  Row(auto& s) : stmt(s) {}

  inline Col operator[](const std::string& col) const {
    return Col{stmt.getColumn(col.c_str())};
  }
  inline Col operator[](const char* col) const {
    return Col{stmt.getColumn(col)};
  }
};


export
class SqliteDB  {
public:
  template<typename... Args>
  using params = std::tuple<Args...>;
  using prepared_t = SQLite::Statement;
  SQLite::Database connection;

  inline auto query(auto& txn, auto& stmt, const auto& args) {
    txn.bind(stmt, args);
    ;
    return std::views::repeat(0)          // infinite view of meaningless values
      | std::views::take_while([&](int){
        return bool(stmt.executeStep());
      })
      | std::views::transform([&](int){ return Row{stmt}; });
  }

  SqliteDB(const Config& config) : connection(config.sqlite_connect_string.c_str(), SQLite::OPEN_READWRITE|SQLite::OPEN_CREATE) {
  }

  Transaction<SqliteDB> begin(this auto& self) {
    return Transaction<SqliteDB>{self};
  };

  SQLite::Statement prepare(this auto& self, const std::string_view query) {
    
    auto res = util::iter_replace
      (query, "$$", 
       [](std::string acc, auto&& subrange) {
         acc += "?";
         acc.append(subrange.begin(), subrange.end()); // append word
         return acc;
       }
       );
    res = util::iter_replace
      (res, "$now",
       [](std::string acc, auto&& subrange) {
         acc += "?";
         acc.append(subrange.begin(), subrange.end()); // append word
         return acc;
       }
       );
                             
    return SQLite::Statement{self.connection, res};
  }

  
};

#+end_src

** Stub
If we are building without sqlite support, then we just need an empty module stub to include elsewhere.

#+begin_src c++ :tangle SqliteStub.cppm
export module Sqlite;

export
class SqliteDB  {
public:
  SqliteDB(auto&) {}

};

#+end_src
