* Classic Bandwidthd
This is the main entry point for the classic mode. It aims to be fully compatible with the original version. If you want
to build it once and decide at runtime which features to enable, this is the target to build.

#+begin_src c++ :tangle "Classic.cpp"
import BandwidthD;
import Parser;
import Memory;
import Cursor;
import Postgres;
import Sqlite;
import TrafficGraph;
import Syslog;

import <print>;
import <unordered_map>;
import <fstream>;
import <chrono>;
import <vector>;
import <ranges>;
import <type_traits>;
import <functional>;

import <unistd.h>;

#+end_src

** Using namespaces
Everything library-related in bandwidthd is in the ~bandwidthd~ namespace. We'll use most of it, so just use the whole
namespace. We could put our symbols inside it, too, but there's not a major reason to do so for applications.

~std::chrono::literals~ lets you write ~200s~ to mean 200 seconds. We could grab /just/ the seconds, but there are no
collisions with other literal namespaces.

#+begin_src c++ :tangle "Classic.cpp"

using namespace std::chrono_literals;
using namespace bandwidthd;

#+end_src

** HasSqlite / HasPostgres
These are consteval (compile-time only) functions which determine if we're building with the database drivers or the
stubs. The type checker gets kinda testy about names /missing/, so the stubs give an empty version of the class, which
we can detect here.

#+begin_src c++ :tangle "Classic.cpp"


consteval bool HasSqlite() {
  return !std::is_empty_v<SqliteDB>;
}

consteval bool HasPostgres() {
  return !std::is_empty_v<PostgresDB>;
}

#+end_src
** ClassicSensor
These are probably the worst 22 lines in the project. ClassicSensor is a CRTP Sensor, which holds a refernce to each of
3 database drivers. It uses the core default IPv4 and IPv6 processor, rather than supplying its own packet processing
function.

~maybe_ref~ allows compile time /or/ runtime selection between an empty optional or the real database.  

#+begin_src c++ :tangle "Classic.cpp"


template<typename MEM, typename PG_CURSOR, typename SQ_CURSOR>
class ClassicSensor: public Sensor<ClassicSensor<MEM, PG_CURSOR, SQ_CURSOR>, Modes::BothDefault>  {
  template<typename T>
  constexpr auto maybe_ref(T& r) {
    if constexpr (std::is_same_v<std::remove_cvref_t<T>, std::optional<typename T::value_type>>) {
      if (r) {
        return std::optional<std::reference_wrapper<typename T::value_type>>{*r};
      }
      else {
        return std::optional<std::reference_wrapper<typename T::value_type>>{std::nullopt};
      }
    }
    else {
      return std::optional<std::reference_wrapper<T>>{r};
    }
  }
  
public:
  MEM& mem;
  std::optional<std::reference_wrapper<PG_CURSOR>> pg_cursor;
  std::optional<std::reference_wrapper<SQ_CURSOR>> sq_cursor;
  int pg_sensor_id;
  int sq_sensor_id;

  ClassicSensor(Config& config, MEM& mem, auto& pg_cursor, auto& sq_cursor):
    Sensor<ClassicSensor<MEM, PG_CURSOR, SQ_CURSOR>, Modes::BothDefault>(config),
    mem(mem),
    pg_cursor(maybe_ref(pg_cursor)),
    sq_cursor(maybe_ref(sq_cursor)) {
    if constexpr (HasPostgres()) {
      if (this->pg_cursor) {
        pg_sensor_id = this->pg_cursor.value().get().GetSensorId();
      }
    }
    if constexpr (HasSqlite()) {
      if (this->sq_cursor) {
        sq_sensor_id = this->sq_cursor.value().get().GetSensorId();
      }
    }
  }

#+end_src

** Main Loop
This is the top level loop. All configuration is done before we get here (RAII).
It's possible to initialize multiple sensors in the same process, so they have a ~poll~ based async poll / step. This
probably /should/ use epoll, but the overhead for a single fd is low enough to not warrant the extra complexity.
Since the classic version only starts a single sensor, we just spin on it.

~Poll~ optionally takes the number of seconds to wait, which defaults to ~1s~. It turns errno into an exception if the
~poll~ call fails. Every so often (~200s~ by default), the inner loop ends and collated data is recorded or graphed.



#+begin_src c++ :tangle "Classic.cpp"


  int Run(this auto& base) {
    uint32_t count{0};
    for (;;) {
      const auto start_time = std::chrono::system_clock::now();
      auto now = std::chrono::system_clock::now();
      while (((now = std::chrono::system_clock::now()) - start_time) < base.config.interval) {
        if (base.Poll()) {
          base.Step();
        }
      }
      if (base.config.output_cdf || base.config.graph_intervals) {
        base.mem.CollateData(base.ips, base.txrx, base.config.interval);
        base.mem.CollateData(base.ips6, base.txrx6, base.config.interval);
      }

#+end_src
*** Sql Outputs

If one of the sql backends is disabled, the ~if constexpr~ blocks will not be compiled. Otherwise this turns into a
runtime check to see if the sql backend is currently active.

#+begin_src c++ :tangle "Classic.cpp"
      if constexpr (HasPostgres()) {
        if (base.pg_cursor) {
          auto& p = base.pg_cursor.value().get();
          p.UpdateSensor(base.pg_sensor_id);
          p.SerializeData(base.pg_sensor_id, base.ips, base.txrx, base.config.interval, now);
          p.SerializeData(base.pg_sensor_id, base.ips6, base.txrx6, base.config.interval, now);
        }
      }
      if constexpr (HasSqlite()) {
        if (base.sq_cursor) {
          auto& s = base.sq_cursor.value().get();
          s.UpdateSensor(base.sq_sensor_id);
          s.SerializeData(base.sq_sensor_id, base.ips, base.txrx, base.config.interval, now);
          s.SerializeData(base.sq_sensor_id, base.ips6, base.txrx6, base.config.interval, now);
        }
      }
#+end_src
*** Graphing
We output standard hd svgs. Since they're svgs, they're infinitely resizeable, but this makes the text nicely readable
at the default zoom on modern displays. To allow passing parameters by name, the graph config is its own standard-layout
type. This requires the ~{{ ... }}~. The actual graph generation is done by the in-memory database driver.

TODO: Write cdf to file instead of stdout.

#+begin_src c++ :tangle "Classic.cpp"

      if (! (count++ % (base.config.skip_intervals + 1))) {
        if (base.config.graph_intervals) {
          TrafficGraph grapher{{.width=1920, .height=1080, .left_margin=150, .top_margin=150, .bottom_margin=50, .right_margin=100}};
          base.mem.Graph(grapher);
        }
        if (base.config.output_cdf) {
          std::string cdf = base.mem.MakeCdf();
          std::filesystem::path log_dir { base.config.log_dir };
          if (!std::filesystem::exists(log_dir)) {
            std::filesystem::create_directories(log_dir);
          }
          constexpr auto FLAGS = std::ios::binary | std::ios::out | std::ios::trunc;

          std::ofstream cdf_file{log_dir / "bandwidthd.cdf", FLAGS};
          cdf_file << cdf << "\n";
        }
      }
#+end_src
*** Resetting
Each vector of ip data needs clearing after every interval. The persistent data is kept inside ~mem~. These attributes
are checked by the compiler. Initially this was done via casting ~*this~ to ~Sensor&~, but C++23's /deducing this/ gives
a slightly easier means of letting the compiler verify the names are correct.

#+begin_src c++ :tangle "Classic.cpp"

      base.ips.clear();
      base.ips6.clear();
      base.txrx.clear();
      base.txrx6.clear();
    }
    return 0;
  }
};

#+end_src

** CPP Main
This is the C++ entry point. It creates and owns all the top level objects, and ensures they are correctly configured
before launching the main loop. This would be where to set up additional sensors in a more complex version.
It also forks to the background and writes its pidfile.

#+begin_src c++ :tangle "Classic.cpp"


int Main(const std::vector<std::string>& args) {
  Config config{};
  config.interval = 200s;
  config.syslog_prefix = "bandwidthd";
  config.filter = "tcp";
  config.graph_individual_ips = true;
  bool background = true;

  bool cfg_file = false;
  for (const auto& arg : args | std::views::drop(1)) {
    if (cfg_file) {
      Parser parser{arg};
      parser.parse(config);
      cfg_file = false;
      continue;
    }
    if (arg == "-D") {
      background = false;
      continue;
    }
    if (arg == "-c") {
      cfg_file = true;
      continue;
    }
    if ((arg == "-h") || (arg == "--help")) {
        std::println("Usage: {} [-c conf] [-D]", args[0]);
        return 1;
    }
    std::println("Improper argument: {}", arg);
    return 1;
  }

  if (config.psql_connect_string.empty() && config.sqlite_connect_string.empty() && 
      (!config.output_cdf && !config.graph_intervals)) {
    std::println("Not sending to database, graphing, or writing cdfs, nothing to do!");
    return 1;
  }

#+end_src
*** Cursor Check
~std::conditional_t~ Returns 1 of 2 types based on the predicate. In this case, we check if either of our db drivers are
empty. If they are, we use the empty type as our stubbed cursor. Otherwise we set up our cursor + driver type. This one
/doesn't/ rely on crtp, as the relationship is uni-directional.

#+begin_src c++ :tangle "Classic.cpp"

  using PostgresCursor = std::conditional_t<
    HasPostgres(),
    Cursor<PostgresDB>,
    PostgresDB
    >;

  using SqliteCursor = std::conditional_t<
    HasSqlite(),
    Cursor<SqliteDB>,
    SqliteDB
    >;

  std::optional<PostgresCursor> pg_cursor{};
  if (!config.psql_connect_string.empty()) {
    if constexpr (HasPostgres()) {
      pg_cursor.emplace(config);
    }
    else {
      std::println("Postgres backend requested, but postgres support not built.");
      return 1;
    }
  }

  std::optional<SqliteCursor> sq_cursor{};
  if (!config.sqlite_connect_string.empty()) {
    if constexpr (HasSqlite()) {
      sq_cursor.emplace(config);
    }
    else {
      std::println("Sqlite backend requested, but sqlite support not built.");
      return 1;
    }
  }
  
  Memory memory{config};
  ClassicSensor<Memory, PostgresCursor, SqliteCursor> sensor{config, memory, pg_cursor, sq_cursor};

#+end_src
*** Fork
If we're supposed to run in the background, this is where to do it.

#+begin_src c++ :tangle "Classic.cpp"


  if (background && fork()) {
    return 0;
  }
  return sensor.Run();
}
#+end_src

** main

This is the portable main entry. It just builds a vector of args and calls Main. Adding platform-specific entries
would be fairly straightforward, to just forward the startup.

#+begin_src c++ :tangle "Classic.cpp"

int main(const int argc, const char * const * const argv) {
  const std::vector<std::string> args{argv, argv + argc};
  return Main(args);
}

#+end_src
